(globalThis.TURBOPACK || (globalThis.TURBOPACK = [])).push([typeof document === "object" ? document.currentScript : undefined,
"[project]/node_modules/graphology-utils/is-graph.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

/**
 * Graphology isGraph
 * ===================
 *
 * Very simple function aiming at ensuring the given variable is a
 * graphology instance.
 */ /**
 * Checking the value is a graphology instance.
 *
 * @param  {any}     value - Target value.
 * @return {boolean}
 */ module.exports = function isGraph(value) {
    return value !== null && typeof value === 'object' && typeof value.addUndirectedEdgeWithKey === 'function' && typeof value.dropNode === 'function' && typeof value.multi === 'boolean';
};
}),
"[project]/node_modules/graphology-utils/defaults.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

/**
 * Graphology Defaults
 * ====================
 *
 * Helper function used throughout the standard lib to resolve defaults.
 */ function isLeaf(o) {
    return !o || typeof o !== 'object' || typeof o === 'function' || Array.isArray(o) || o instanceof Set || o instanceof Map || o instanceof RegExp || o instanceof Date;
}
function resolveDefaults(target, defaults) {
    target = target || {};
    var output = {};
    for(var k in defaults){
        var existing = target[k];
        var def = defaults[k];
        // Recursion
        if (!isLeaf(def)) {
            output[k] = resolveDefaults(existing, def);
            continue;
        }
        // Leaf
        if (existing === undefined) {
            output[k] = def;
        } else {
            output[k] = existing;
        }
    }
    return output;
}
module.exports = resolveDefaults;
}),
"[project]/node_modules/graphology-utils/getters.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

/**
 * Graphology Weight Getter
 * =========================
 *
 * Function creating weight getters.
 */ function coerceWeight(value) {
    // Ensuring target value is a correct number
    if (typeof value !== 'number' || isNaN(value)) return 1;
    return value;
}
function createNodeValueGetter(nameOrFunction, defaultValue) {
    var getter = {};
    var coerceToDefault = function(v) {
        if (typeof v === 'undefined') return defaultValue;
        return v;
    };
    if (typeof defaultValue === 'function') coerceToDefault = defaultValue;
    var get = function(attributes) {
        return coerceToDefault(attributes[nameOrFunction]);
    };
    var returnDefault = function() {
        return coerceToDefault(undefined);
    };
    if (typeof nameOrFunction === 'string') {
        getter.fromAttributes = get;
        getter.fromGraph = function(graph, node) {
            return get(graph.getNodeAttributes(node));
        };
        getter.fromEntry = function(node, attributes) {
            return get(attributes);
        };
    } else if (typeof nameOrFunction === 'function') {
        getter.fromAttributes = function() {
            throw new Error('graphology-utils/getters/createNodeValueGetter: irrelevant usage.');
        };
        getter.fromGraph = function(graph, node) {
            return coerceToDefault(nameOrFunction(node, graph.getNodeAttributes(node)));
        };
        getter.fromEntry = function(node, attributes) {
            return coerceToDefault(nameOrFunction(node, attributes));
        };
    } else {
        getter.fromAttributes = returnDefault;
        getter.fromGraph = returnDefault;
        getter.fromEntry = returnDefault;
    }
    return getter;
}
function createEdgeValueGetter(nameOrFunction, defaultValue) {
    var getter = {};
    var coerceToDefault = function(v) {
        if (typeof v === 'undefined') return defaultValue;
        return v;
    };
    if (typeof defaultValue === 'function') coerceToDefault = defaultValue;
    var get = function(attributes) {
        return coerceToDefault(attributes[nameOrFunction]);
    };
    var returnDefault = function() {
        return coerceToDefault(undefined);
    };
    if (typeof nameOrFunction === 'string') {
        getter.fromAttributes = get;
        getter.fromGraph = function(graph, edge) {
            return get(graph.getEdgeAttributes(edge));
        };
        getter.fromEntry = function(edge, attributes) {
            return get(attributes);
        };
        getter.fromPartialEntry = getter.fromEntry;
        getter.fromMinimalEntry = getter.fromEntry;
    } else if (typeof nameOrFunction === 'function') {
        getter.fromAttributes = function() {
            throw new Error('graphology-utils/getters/createEdgeValueGetter: irrelevant usage.');
        };
        getter.fromGraph = function(graph, edge) {
            // TODO: we can do better, check #310
            var extremities = graph.extremities(edge);
            return coerceToDefault(nameOrFunction(edge, graph.getEdgeAttributes(edge), extremities[0], extremities[1], graph.getNodeAttributes(extremities[0]), graph.getNodeAttributes(extremities[1]), graph.isUndirected(edge)));
        };
        getter.fromEntry = function(e, a, s, t, sa, ta, u) {
            return coerceToDefault(nameOrFunction(e, a, s, t, sa, ta, u));
        };
        getter.fromPartialEntry = function(e, a, s, t) {
            return coerceToDefault(nameOrFunction(e, a, s, t));
        };
        getter.fromMinimalEntry = function(e, a) {
            return coerceToDefault(nameOrFunction(e, a));
        };
    } else {
        getter.fromAttributes = returnDefault;
        getter.fromGraph = returnDefault;
        getter.fromEntry = returnDefault;
        getter.fromMinimalEntry = returnDefault;
    }
    return getter;
}
exports.createNodeValueGetter = createNodeValueGetter;
exports.createEdgeValueGetter = createEdgeValueGetter;
exports.createEdgeWeightGetter = function(name) {
    return createEdgeValueGetter(name, coerceWeight);
};
}),
"[project]/node_modules/graphology-layout-force/iterate.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

/**
 * Graphology Force Layout Iteration
 * ==================================
 *
 * Function describing a single iteration of the force layout.
 */ const { createNodeValueGetter, createEdgeValueGetter } = __turbopack_context__.r("[project]/node_modules/graphology-utils/getters.js [app-client] (ecmascript)");
// const EPSILON = -Infinity;
// function isVeryCloseToZero(x) {
//   return Math.abs(x) < EPSILON;
// }
module.exports = function iterate(graph, nodeStates, params) {
    const { nodeXAttribute: xKey, nodeYAttribute: yKey } = params;
    const { attraction, repulsion, gravity, inertia, maxMove } = params.settings;
    let { shouldSkipNode, shouldSkipEdge, isNodeFixed } = params;
    isNodeFixed = createNodeValueGetter(isNodeFixed);
    shouldSkipNode = createNodeValueGetter(shouldSkipNode, false);
    shouldSkipEdge = createEdgeValueGetter(shouldSkipEdge, false);
    const nodes = graph.filterNodes((n, attr)=>{
        return !shouldSkipNode.fromEntry(n, attr);
    });
    const adjustedOrder = nodes.length;
    // Check nodeStatess and inertia
    for(let i = 0; i < adjustedOrder; i++){
        const n = nodes[i];
        const attr = graph.getNodeAttributes(n);
        const nodeState = nodeStates[n];
        if (!nodeState) nodeStates[n] = {
            dx: 0,
            dy: 0,
            x: attr[xKey] || 0,
            y: attr[yKey] || 0
        };
        else nodeStates[n] = {
            dx: nodeState.dx * inertia,
            dy: nodeState.dy * inertia,
            x: attr[xKey] || 0,
            y: attr[yKey] || 0
        };
    }
    // Repulsion
    if (repulsion) for(let i = 0; i < adjustedOrder; i++){
        const n1 = nodes[i];
        const n1State = nodeStates[n1];
        for(let j = i + 1; j < adjustedOrder; j++){
            const n2 = nodes[j];
            const n2State = nodeStates[n2];
            // Compute distance:
            const dx = n2State.x - n1State.x;
            const dy = n2State.y - n1State.y;
            const distance = Math.sqrt(dx * dx + dy * dy) || 1;
            // Repulse nodes relatively to 1 / distance:
            const repulsionX = repulsion / distance * dx;
            const repulsionY = repulsion / distance * dy;
            n1State.dx -= repulsionX;
            n1State.dy -= repulsionY;
            n2State.dx += repulsionX;
            n2State.dy += repulsionY;
        }
    }
    // Attraction
    if (attraction) graph.forEachEdge((edge, attr, source, target, sourceAttr, targetAttr, undirected)=>{
        if (source === target) return;
        if (shouldSkipNode.fromEntry(source, sourceAttr) || shouldSkipNode.fromEntry(target, targetAttr)) return;
        if (shouldSkipEdge.fromEntry(edge, attr, source, target, sourceAttr, targetAttr, undirected)) return;
        const n1State = nodeStates[source];
        const n2State = nodeStates[target];
        // Compute distance:
        const dx = n2State.x - n1State.x;
        const dy = n2State.y - n1State.y;
        const distance = Math.sqrt(dx * dx + dy * dy) || 1;
        // Attract nodes relatively to their distance:
        const attractionX = attraction * distance * dx;
        const attractionY = attraction * distance * dy;
        n1State.dx += attractionX;
        n1State.dy += attractionY;
        n2State.dx -= attractionX;
        n2State.dy -= attractionY;
    });
    // Gravity
    if (gravity) for(let i = 0; i < adjustedOrder; i++){
        const n = nodes[i];
        const nodeState = nodeStates[n];
        // Attract nodes to [0, 0] relatively to the distance:
        const { x, y } = nodeState;
        const distance = Math.sqrt(x * x + y * y) || 1;
        nodeStates[n].dx -= x * gravity * distance;
        nodeStates[n].dy -= y * gravity * distance;
    }
    // Apply forces
    const converged = false;
    for(let i = 0; i < adjustedOrder; i++){
        const n = nodes[i];
        const nodeState = nodeStates[n];
        const distance = Math.sqrt(nodeState.dx * nodeState.dx + nodeState.dy * nodeState.dy);
        if (distance > maxMove) {
            nodeState.dx *= maxMove / distance;
            nodeState.dy *= maxMove / distance;
        }
        // if (!isVeryCloseToZero(nodeState.dx) || !isVeryCloseToZero(nodeState.dy)) {
        //   converged = false;
        // }
        if (!isNodeFixed.fromGraph(graph, n)) {
            nodeState.x += nodeState.dx;
            nodeState.y += nodeState.dy;
            nodeState.fixed = false;
        } else {
            nodeState.fixed = true;
        }
    // NOTE: possibility to assign here to save one loop in the future
    }
    return {
        converged
    };
};
}),
"[project]/node_modules/graphology-layout-force/helpers.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

/**
 * Graphology Force Layout Helpers
 * ================================
 *
 * Miscellaneous helper functions related to the force layout.
 */ exports.assignLayoutChanges = function(graph, nodeStates, params) {
    const { nodeXAttribute: x, nodeYAttribute: y } = params;
    graph.updateEachNodeAttributes((n, attr)=>{
        const state = nodeStates[n];
        if (!state || state.fixed) return attr;
        attr[x] = state.x;
        attr[y] = state.y;
        return attr;
    }, {
        attributes: [
            'x',
            'y'
        ]
    });
};
exports.collectLayoutChanges = function(nodeStates) {
    const mapping = {};
    for(const n in nodeStates){
        const state = nodeStates[n];
        mapping[n] = {
            x: state.x,
            y: state.y
        };
    }
    return mapping;
};
}),
"[project]/node_modules/graphology-layout-force/defaults.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

/**
 * Graphology Force Layout Defaults
 * =================================
 *
 * Default options & settings used by the library.
 */ module.exports = {
    nodeXAttribute: 'x',
    nodeYAttribute: 'y',
    isNodeFixed: 'fixed',
    shouldSkipNode: null,
    shouldSkipEdge: null,
    settings: {
        attraction: 0.0005,
        repulsion: 0.1,
        gravity: 0.0001,
        inertia: 0.6,
        maxMove: 200
    }
};
}),
"[project]/node_modules/graphology-layout-force/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

/**
 * Graphology Force Layout
 * ========================
 *
 * A simple force-directed layout algorithm for graphology.
 */ const isGraph = __turbopack_context__.r("[project]/node_modules/graphology-utils/is-graph.js [app-client] (ecmascript)");
const resolveDefaults = __turbopack_context__.r("[project]/node_modules/graphology-utils/defaults.js [app-client] (ecmascript)");
const iterate = __turbopack_context__.r("[project]/node_modules/graphology-layout-force/iterate.js [app-client] (ecmascript)");
const helpers = __turbopack_context__.r("[project]/node_modules/graphology-layout-force/helpers.js [app-client] (ecmascript)");
const DEFAULTS = __turbopack_context__.r("[project]/node_modules/graphology-layout-force/defaults.js [app-client] (ecmascript)");
/**
 * Asbtract function used to run the layout for a certain number of iterations.
 *
 * @param  {boolean}       assign       - Whether to assign positions.
 * @param  {Graph}         graph        - Target graph.
 * @param  {object|number} params       - If number, params.maxIterations, else:
 * @param  {number}          maxIterations - Maximum number of iterations.
 * @param  {object}          [settings] - Settings.
 * @return {object|undefined}
 */ function abstractSynchronousLayout(assign, graph, params) {
    if (!isGraph(graph)) throw new Error('graphology-layout-force: the given graph is not a valid graphology instance.');
    if (typeof params === 'number') params = {
        maxIterations: params
    };
    else params = params || {};
    const maxIterations = params.maxIterations;
    params = resolveDefaults(params, DEFAULTS);
    if (typeof maxIterations !== 'number' || maxIterations <= 0) throw new Error('graphology-layout-force: you should provide a positive number of maximum iterations.');
    // Iteration state
    const nodeStates = {};
    let result = null;
    let i;
    // Iterating
    for(i = 0; i < maxIterations; i++){
        result = iterate(graph, nodeStates, params);
        if (result.converged) break;
    }
    // Applying
    if (assign) {
        helpers.assignLayoutChanges(graph, nodeStates, params);
        return;
    }
    return helpers.collectLayoutChanges(nodeStates);
}
/**
 * Exporting.
 */ const synchronousLayout = abstractSynchronousLayout.bind(null, false);
synchronousLayout.assign = abstractSynchronousLayout.bind(null, true);
module.exports = synchronousLayout;
}),
]);

//# sourceMappingURL=node_modules_17fa20be._.js.map
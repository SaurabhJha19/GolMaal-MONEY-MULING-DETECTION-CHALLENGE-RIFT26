{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 3, "column": 0}, "map": {"version":3,"sources":["file:///E:/2026/RIFT%2726/Main_Project/frontend/node_modules/graphology-utils/is-graph.js"],"sourcesContent":["/**\n * Graphology isGraph\n * ===================\n *\n * Very simple function aiming at ensuring the given variable is a\n * graphology instance.\n */\n\n/**\n * Checking the value is a graphology instance.\n *\n * @param  {any}     value - Target value.\n * @return {boolean}\n */\nmodule.exports = function isGraph(value) {\n  return (\n    value !== null &&\n    typeof value === 'object' &&\n    typeof value.addUndirectedEdgeWithKey === 'function' &&\n    typeof value.dropNode === 'function' &&\n    typeof value.multi === 'boolean'\n  );\n};\n"],"names":[],"mappings":"AAAA;;;;;;CAMC,GAED;;;;;CAKC,GACD,OAAO,OAAO,GAAG,SAAS,QAAQ,KAAK;IACrC,OACE,UAAU,QACV,OAAO,UAAU,YACjB,OAAO,MAAM,wBAAwB,KAAK,cAC1C,OAAO,MAAM,QAAQ,KAAK,cAC1B,OAAO,MAAM,KAAK,KAAK;AAE3B","ignoreList":[0]}},
    {"offset": {"line": 20, "column": 0}, "map": {"version":3,"sources":["file:///E:/2026/RIFT%2726/Main_Project/frontend/node_modules/graphology-utils/defaults.js"],"sourcesContent":["/**\n * Graphology Defaults\n * ====================\n *\n * Helper function used throughout the standard lib to resolve defaults.\n */\nfunction isLeaf(o) {\n  return (\n    !o ||\n    typeof o !== 'object' ||\n    typeof o === 'function' ||\n    Array.isArray(o) ||\n    o instanceof Set ||\n    o instanceof Map ||\n    o instanceof RegExp ||\n    o instanceof Date\n  );\n}\n\nfunction resolveDefaults(target, defaults) {\n  target = target || {};\n\n  var output = {};\n\n  for (var k in defaults) {\n    var existing = target[k];\n    var def = defaults[k];\n\n    // Recursion\n    if (!isLeaf(def)) {\n      output[k] = resolveDefaults(existing, def);\n\n      continue;\n    }\n\n    // Leaf\n    if (existing === undefined) {\n      output[k] = def;\n    } else {\n      output[k] = existing;\n    }\n  }\n\n  return output;\n}\n\nmodule.exports = resolveDefaults;\n"],"names":[],"mappings":"AAAA;;;;;CAKC,GACD,SAAS,OAAO,CAAC;IACf,OACE,CAAC,KACD,OAAO,MAAM,YACb,OAAO,MAAM,cACb,MAAM,OAAO,CAAC,MACd,aAAa,OACb,aAAa,OACb,aAAa,UACb,aAAa;AAEjB;AAEA,SAAS,gBAAgB,MAAM,EAAE,QAAQ;IACvC,SAAS,UAAU,CAAC;IAEpB,IAAI,SAAS,CAAC;IAEd,IAAK,IAAI,KAAK,SAAU;QACtB,IAAI,WAAW,MAAM,CAAC,EAAE;QACxB,IAAI,MAAM,QAAQ,CAAC,EAAE;QAErB,YAAY;QACZ,IAAI,CAAC,OAAO,MAAM;YAChB,MAAM,CAAC,EAAE,GAAG,gBAAgB,UAAU;YAEtC;QACF;QAEA,OAAO;QACP,IAAI,aAAa,WAAW;YAC1B,MAAM,CAAC,EAAE,GAAG;QACd,OAAO;YACL,MAAM,CAAC,EAAE,GAAG;QACd;IACF;IAEA,OAAO;AACT;AAEA,OAAO,OAAO,GAAG","ignoreList":[0]}},
    {"offset": {"line": 52, "column": 0}, "map": {"version":3,"sources":["file:///E:/2026/RIFT%2726/Main_Project/frontend/node_modules/graphology-utils/getters.js"],"sourcesContent":["/**\n * Graphology Weight Getter\n * =========================\n *\n * Function creating weight getters.\n */\nfunction coerceWeight(value) {\n  // Ensuring target value is a correct number\n  if (typeof value !== 'number' || isNaN(value)) return 1;\n\n  return value;\n}\n\nfunction createNodeValueGetter(nameOrFunction, defaultValue) {\n  var getter = {};\n\n  var coerceToDefault = function (v) {\n    if (typeof v === 'undefined') return defaultValue;\n\n    return v;\n  };\n\n  if (typeof defaultValue === 'function') coerceToDefault = defaultValue;\n\n  var get = function (attributes) {\n    return coerceToDefault(attributes[nameOrFunction]);\n  };\n\n  var returnDefault = function () {\n    return coerceToDefault(undefined);\n  };\n\n  if (typeof nameOrFunction === 'string') {\n    getter.fromAttributes = get;\n    getter.fromGraph = function (graph, node) {\n      return get(graph.getNodeAttributes(node));\n    };\n    getter.fromEntry = function (node, attributes) {\n      return get(attributes);\n    };\n  } else if (typeof nameOrFunction === 'function') {\n    getter.fromAttributes = function () {\n      throw new Error(\n        'graphology-utils/getters/createNodeValueGetter: irrelevant usage.'\n      );\n    };\n    getter.fromGraph = function (graph, node) {\n      return coerceToDefault(\n        nameOrFunction(node, graph.getNodeAttributes(node))\n      );\n    };\n    getter.fromEntry = function (node, attributes) {\n      return coerceToDefault(nameOrFunction(node, attributes));\n    };\n  } else {\n    getter.fromAttributes = returnDefault;\n    getter.fromGraph = returnDefault;\n    getter.fromEntry = returnDefault;\n  }\n\n  return getter;\n}\n\nfunction createEdgeValueGetter(nameOrFunction, defaultValue) {\n  var getter = {};\n\n  var coerceToDefault = function (v) {\n    if (typeof v === 'undefined') return defaultValue;\n\n    return v;\n  };\n\n  if (typeof defaultValue === 'function') coerceToDefault = defaultValue;\n\n  var get = function (attributes) {\n    return coerceToDefault(attributes[nameOrFunction]);\n  };\n\n  var returnDefault = function () {\n    return coerceToDefault(undefined);\n  };\n\n  if (typeof nameOrFunction === 'string') {\n    getter.fromAttributes = get;\n    getter.fromGraph = function (graph, edge) {\n      return get(graph.getEdgeAttributes(edge));\n    };\n    getter.fromEntry = function (edge, attributes) {\n      return get(attributes);\n    };\n    getter.fromPartialEntry = getter.fromEntry;\n    getter.fromMinimalEntry = getter.fromEntry;\n  } else if (typeof nameOrFunction === 'function') {\n    getter.fromAttributes = function () {\n      throw new Error(\n        'graphology-utils/getters/createEdgeValueGetter: irrelevant usage.'\n      );\n    };\n    getter.fromGraph = function (graph, edge) {\n      // TODO: we can do better, check #310\n      var extremities = graph.extremities(edge);\n      return coerceToDefault(\n        nameOrFunction(\n          edge,\n          graph.getEdgeAttributes(edge),\n          extremities[0],\n          extremities[1],\n          graph.getNodeAttributes(extremities[0]),\n          graph.getNodeAttributes(extremities[1]),\n          graph.isUndirected(edge)\n        )\n      );\n    };\n    getter.fromEntry = function (e, a, s, t, sa, ta, u) {\n      return coerceToDefault(nameOrFunction(e, a, s, t, sa, ta, u));\n    };\n    getter.fromPartialEntry = function (e, a, s, t) {\n      return coerceToDefault(nameOrFunction(e, a, s, t));\n    };\n    getter.fromMinimalEntry = function (e, a) {\n      return coerceToDefault(nameOrFunction(e, a));\n    };\n  } else {\n    getter.fromAttributes = returnDefault;\n    getter.fromGraph = returnDefault;\n    getter.fromEntry = returnDefault;\n    getter.fromMinimalEntry = returnDefault;\n  }\n\n  return getter;\n}\n\nexports.createNodeValueGetter = createNodeValueGetter;\nexports.createEdgeValueGetter = createEdgeValueGetter;\nexports.createEdgeWeightGetter = function (name) {\n  return createEdgeValueGetter(name, coerceWeight);\n};\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 157, "column": 0}, "map": {"version":3,"sources":["file:///E:/2026/RIFT%2726/Main_Project/frontend/node_modules/graphology-layout-force/iterate.js"],"sourcesContent":["/**\n * Graphology Force Layout Iteration\n * ==================================\n *\n * Function describing a single iteration of the force layout.\n */\nconst {\n  createNodeValueGetter,\n  createEdgeValueGetter\n} = require('graphology-utils/getters');\n\n// const EPSILON = -Infinity;\n\n// function isVeryCloseToZero(x) {\n//   return Math.abs(x) < EPSILON;\n// }\n\nmodule.exports = function iterate(graph, nodeStates, params) {\n  const {nodeXAttribute: xKey, nodeYAttribute: yKey} = params;\n  const {attraction, repulsion, gravity, inertia, maxMove} = params.settings;\n\n  let {shouldSkipNode, shouldSkipEdge, isNodeFixed} = params;\n\n  isNodeFixed = createNodeValueGetter(isNodeFixed);\n  shouldSkipNode = createNodeValueGetter(shouldSkipNode, false);\n  shouldSkipEdge = createEdgeValueGetter(shouldSkipEdge, false);\n\n  const nodes = graph.filterNodes((n, attr) => {\n    return !shouldSkipNode.fromEntry(n, attr);\n  });\n\n  const adjustedOrder = nodes.length;\n\n  // Check nodeStatess and inertia\n  for (let i = 0; i < adjustedOrder; i++) {\n    const n = nodes[i];\n    const attr = graph.getNodeAttributes(n);\n    const nodeState = nodeStates[n];\n\n    if (!nodeState)\n      nodeStates[n] = {\n        dx: 0,\n        dy: 0,\n        x: attr[xKey] || 0,\n        y: attr[yKey] || 0\n      };\n    else\n      nodeStates[n] = {\n        dx: nodeState.dx * inertia,\n        dy: nodeState.dy * inertia,\n        x: attr[xKey] || 0,\n        y: attr[yKey] || 0\n      };\n  }\n\n  // Repulsion\n  if (repulsion)\n    for (let i = 0; i < adjustedOrder; i++) {\n      const n1 = nodes[i];\n      const n1State = nodeStates[n1];\n\n      for (let j = i + 1; j < adjustedOrder; j++) {\n        const n2 = nodes[j];\n        const n2State = nodeStates[n2];\n\n        // Compute distance:\n        const dx = n2State.x - n1State.x;\n        const dy = n2State.y - n1State.y;\n        const distance = Math.sqrt(dx * dx + dy * dy) || 1;\n\n        // Repulse nodes relatively to 1 / distance:\n        const repulsionX = (repulsion / distance) * dx;\n        const repulsionY = (repulsion / distance) * dy;\n        n1State.dx -= repulsionX;\n        n1State.dy -= repulsionY;\n        n2State.dx += repulsionX;\n        n2State.dy += repulsionY;\n      }\n    }\n\n  // Attraction\n  if (attraction)\n    graph.forEachEdge(\n      (edge, attr, source, target, sourceAttr, targetAttr, undirected) => {\n        if (source === target) return;\n\n        if (\n          shouldSkipNode.fromEntry(source, sourceAttr) ||\n          shouldSkipNode.fromEntry(target, targetAttr)\n        )\n          return;\n\n        if (\n          shouldSkipEdge.fromEntry(\n            edge,\n            attr,\n            source,\n            target,\n            sourceAttr,\n            targetAttr,\n            undirected\n          )\n        )\n          return;\n\n        const n1State = nodeStates[source];\n        const n2State = nodeStates[target];\n\n        // Compute distance:\n        const dx = n2State.x - n1State.x;\n        const dy = n2State.y - n1State.y;\n\n        const distance = Math.sqrt(dx * dx + dy * dy) || 1;\n\n        // Attract nodes relatively to their distance:\n        const attractionX = attraction * distance * dx;\n        const attractionY = attraction * distance * dy;\n        n1State.dx += attractionX;\n        n1State.dy += attractionY;\n        n2State.dx -= attractionX;\n        n2State.dy -= attractionY;\n      }\n    );\n\n  // Gravity\n  if (gravity)\n    for (let i = 0; i < adjustedOrder; i++) {\n      const n = nodes[i];\n      const nodeState = nodeStates[n];\n\n      // Attract nodes to [0, 0] relatively to the distance:\n      const {x, y} = nodeState;\n      const distance = Math.sqrt(x * x + y * y) || 1;\n      nodeStates[n].dx -= x * gravity * distance;\n      nodeStates[n].dy -= y * gravity * distance;\n    }\n\n  // Apply forces\n  const converged = false;\n\n  for (let i = 0; i < adjustedOrder; i++) {\n    const n = nodes[i];\n    const nodeState = nodeStates[n];\n\n    const distance = Math.sqrt(\n      nodeState.dx * nodeState.dx + nodeState.dy * nodeState.dy\n    );\n\n    if (distance > maxMove) {\n      nodeState.dx *= maxMove / distance;\n      nodeState.dy *= maxMove / distance;\n    }\n\n    // if (!isVeryCloseToZero(nodeState.dx) || !isVeryCloseToZero(nodeState.dy)) {\n    //   converged = false;\n    // }\n\n    if (!isNodeFixed.fromGraph(graph, n)) {\n      nodeState.x += nodeState.dx;\n      nodeState.y += nodeState.dy;\n      nodeState.fixed = false;\n    } else {\n      nodeState.fixed = true;\n    }\n\n    // NOTE: possibility to assign here to save one loop in the future\n  }\n\n  return {converged};\n};\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 274, "column": 0}, "map": {"version":3,"sources":["file:///E:/2026/RIFT%2726/Main_Project/frontend/node_modules/graphology-layout-force/helpers.js"],"sourcesContent":["/**\n * Graphology Force Layout Helpers\n * ================================\n *\n * Miscellaneous helper functions related to the force layout.\n */\nexports.assignLayoutChanges = function (graph, nodeStates, params) {\n  const {nodeXAttribute: x, nodeYAttribute: y} = params;\n\n  graph.updateEachNodeAttributes(\n    (n, attr) => {\n      const state = nodeStates[n];\n\n      if (!state || state.fixed) return attr;\n\n      attr[x] = state.x;\n      attr[y] = state.y;\n\n      return attr;\n    },\n    {attributes: ['x', 'y']}\n  );\n};\n\nexports.collectLayoutChanges = function (nodeStates) {\n  const mapping = {};\n\n  for (const n in nodeStates) {\n    const state = nodeStates[n];\n\n    mapping[n] = {x: state.x, y: state.y};\n  }\n\n  return mapping;\n};\n"],"names":[],"mappings":"AAAA;;;;;CAKC,GACD,QAAQ,mBAAmB,GAAG,SAAU,KAAK,EAAE,UAAU,EAAE,MAAM;IAC/D,MAAM,EAAC,gBAAgB,CAAC,EAAE,gBAAgB,CAAC,EAAC,GAAG;IAE/C,MAAM,wBAAwB,CAC5B,CAAC,GAAG;QACF,MAAM,QAAQ,UAAU,CAAC,EAAE;QAE3B,IAAI,CAAC,SAAS,MAAM,KAAK,EAAE,OAAO;QAElC,IAAI,CAAC,EAAE,GAAG,MAAM,CAAC;QACjB,IAAI,CAAC,EAAE,GAAG,MAAM,CAAC;QAEjB,OAAO;IACT,GACA;QAAC,YAAY;YAAC;YAAK;SAAI;IAAA;AAE3B;AAEA,QAAQ,oBAAoB,GAAG,SAAU,UAAU;IACjD,MAAM,UAAU,CAAC;IAEjB,IAAK,MAAM,KAAK,WAAY;QAC1B,MAAM,QAAQ,UAAU,CAAC,EAAE;QAE3B,OAAO,CAAC,EAAE,GAAG;YAAC,GAAG,MAAM,CAAC;YAAE,GAAG,MAAM,CAAC;QAAA;IACtC;IAEA,OAAO;AACT","ignoreList":[0]}},
    {"offset": {"line": 308, "column": 0}, "map": {"version":3,"sources":["file:///E:/2026/RIFT%2726/Main_Project/frontend/node_modules/graphology-layout-force/defaults.js"],"sourcesContent":["/**\n * Graphology Force Layout Defaults\n * =================================\n *\n * Default options & settings used by the library.\n */\nmodule.exports = {\n  nodeXAttribute: 'x',\n  nodeYAttribute: 'y',\n  isNodeFixed: 'fixed',\n  shouldSkipNode: null,\n  shouldSkipEdge: null,\n  settings: {\n    attraction: 0.0005,\n    repulsion: 0.1,\n    gravity: 0.0001,\n    inertia: 0.6,\n    maxMove: 200\n  }\n};\n"],"names":[],"mappings":"AAAA;;;;;CAKC,GACD,OAAO,OAAO,GAAG;IACf,gBAAgB;IAChB,gBAAgB;IAChB,aAAa;IACb,gBAAgB;IAChB,gBAAgB;IAChB,UAAU;QACR,YAAY;QACZ,WAAW;QACX,SAAS;QACT,SAAS;QACT,SAAS;IACX;AACF","ignoreList":[0]}},
    {"offset": {"line": 330, "column": 0}, "map": {"version":3,"sources":["file:///E:/2026/RIFT%2726/Main_Project/frontend/node_modules/graphology-layout-force/index.js"],"sourcesContent":["/**\n * Graphology Force Layout\n * ========================\n *\n * A simple force-directed layout algorithm for graphology.\n */\nconst isGraph = require('graphology-utils/is-graph');\nconst resolveDefaults = require('graphology-utils/defaults');\n\nconst iterate = require('./iterate.js');\nconst helpers = require('./helpers.js');\n\nconst DEFAULTS = require('./defaults.js');\n\n/**\n * Asbtract function used to run the layout for a certain number of iterations.\n *\n * @param  {boolean}       assign       - Whether to assign positions.\n * @param  {Graph}         graph        - Target graph.\n * @param  {object|number} params       - If number, params.maxIterations, else:\n * @param  {number}          maxIterations - Maximum number of iterations.\n * @param  {object}          [settings] - Settings.\n * @return {object|undefined}\n */\nfunction abstractSynchronousLayout(assign, graph, params) {\n  if (!isGraph(graph))\n    throw new Error(\n      'graphology-layout-force: the given graph is not a valid graphology instance.'\n    );\n\n  if (typeof params === 'number') params = {maxIterations: params};\n  else params = params || {};\n\n  const maxIterations = params.maxIterations;\n\n  params = resolveDefaults(params, DEFAULTS);\n\n  if (typeof maxIterations !== 'number' || maxIterations <= 0)\n    throw new Error(\n      'graphology-layout-force: you should provide a positive number of maximum iterations.'\n    );\n\n  // Iteration state\n  const nodeStates = {};\n  let result = null;\n  let i;\n\n  // Iterating\n  for (i = 0; i < maxIterations; i++) {\n    result = iterate(graph, nodeStates, params);\n\n    if (result.converged) break;\n  }\n\n  // Applying\n  if (assign) {\n    helpers.assignLayoutChanges(graph, nodeStates, params);\n    return;\n  }\n\n  return helpers.collectLayoutChanges(nodeStates);\n}\n\n/**\n * Exporting.\n */\nconst synchronousLayout = abstractSynchronousLayout.bind(null, false);\nsynchronousLayout.assign = abstractSynchronousLayout.bind(null, true);\n\nmodule.exports = synchronousLayout;\n"],"names":[],"mappings":"AAAA;;;;;CAKC,GACD,MAAM;AACN,MAAM;AAEN,MAAM;AACN,MAAM;AAEN,MAAM;AAEN;;;;;;;;;CASC,GACD,SAAS,0BAA0B,MAAM,EAAE,KAAK,EAAE,MAAM;IACtD,IAAI,CAAC,QAAQ,QACX,MAAM,IAAI,MACR;IAGJ,IAAI,OAAO,WAAW,UAAU,SAAS;QAAC,eAAe;IAAM;SAC1D,SAAS,UAAU,CAAC;IAEzB,MAAM,gBAAgB,OAAO,aAAa;IAE1C,SAAS,gBAAgB,QAAQ;IAEjC,IAAI,OAAO,kBAAkB,YAAY,iBAAiB,GACxD,MAAM,IAAI,MACR;IAGJ,kBAAkB;IAClB,MAAM,aAAa,CAAC;IACpB,IAAI,SAAS;IACb,IAAI;IAEJ,YAAY;IACZ,IAAK,IAAI,GAAG,IAAI,eAAe,IAAK;QAClC,SAAS,QAAQ,OAAO,YAAY;QAEpC,IAAI,OAAO,SAAS,EAAE;IACxB;IAEA,WAAW;IACX,IAAI,QAAQ;QACV,QAAQ,mBAAmB,CAAC,OAAO,YAAY;QAC/C;IACF;IAEA,OAAO,QAAQ,oBAAoB,CAAC;AACtC;AAEA;;CAEC,GACD,MAAM,oBAAoB,0BAA0B,IAAI,CAAC,MAAM;AAC/D,kBAAkB,MAAM,GAAG,0BAA0B,IAAI,CAAC,MAAM;AAEhE,OAAO,OAAO,GAAG","ignoreList":[0]}}]
}